{
  "cve_id": "CVE-1999-0276",
  "cve_summary": "mSQL v2.0.1 and below allows remote execution through a buffer overflow.",
  "base_query": "mSQL v2.0.1 and below allows remote execution through a buffer overflow.",
  "decomposed_queries": [
    "mSQL v2.0.1 and below allows remote execution through a buffer overflow.",
    "mSQL v2.0.1 and below allows remote execution through a buffer overrun.",
    "mSQL v2.0.1 and below allows remote execution through a stack overflow."
  ],
  "total_queries": 3,
  "total_matches": 8,
  "unique_files": 8,
  "consolidated": {
    "total_files": 8,
    "files": [
      {
        "file_path": "examples\\tutorial\\tests\\data.sql",
        "avg_score": 0.0,
        "queries": [
          "mSQL v2.0.1 and below allows remote execution through a buffer overflow."
        ],
        "content_snippet": "INSERT INTO user (username, password)\nVALUES\n  ('test', 'pbkdf2:sha256:50000$TCI4GzcX$0de171a4f4dac32e3364c7ddc7c14f3e2fa61f2d17574483f7ffbb431b4acb2f'),\n  ('other', 'pbkdf2:sha256:50000$kJPKsz6N$d2d4784f1b030a9761f5ccaeeaca413f27f2ecb76d6168407af962ddce849f79');\n\nINSERT INTO post (title, body, author_id, created)\nVALUES\n  ('test title', 'test' || x'0a' || 'body', 1, '2018-01-01 00:00:00');\n"
      },
      {
        "file_path": "examples\\tutorial\\flaskr\\schema.sql",
        "avg_score": 0.0,
        "queries": [
          "mSQL v2.0.1 and below allows remote execution through a buffer overflow."
        ],
        "content_snippet": "-- Initialize the database.\n-- Drop any existing data and create empty tables.\n\nDROP TABLE IF EXISTS user;\nDROP TABLE IF EXISTS post;\n\nCREATE TABLE user (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  username TEXT UNIQUE NOT NULL,\n  password TEXT NOT NULL\n);\n\nCREATE TABLE post (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  author_id INTEGER NOT NULL,\n  created TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  title TEXT NOT NULL,\n  body TEXT NOT NULL,\n  FOREIGN KEY (author_id) REFERENCES user (id)\n);\n"
      },
      {
        "file_path": "src\\flask\\__main__.py",
        "avg_score": 0.0,
        "queries": [
          "mSQL v2.0.1 and below allows remote execution through a buffer overflow."
        ],
        "content_snippet": "from .cli import main\n\nmain()\n"
      },
      {
        "file_path": "docs\\deploying\\asgi.rst",
        "avg_score": 0.0,
        "queries": [
          "mSQL v2.0.1 and below allows remote execution through a buffer overflow."
        ],
        "content_snippet": "ASGI\n====\n\nIf you'd like to use an ASGI server you will need to utilise WSGI to\nASGI middleware. The asgiref\n`WsgiToAsgi <https://github.com/django/asgiref#wsgi-to-asgi-adapter>`_\nadapter is recommended as it integrates with the event loop used for\nFlask's :ref:`async_await` support. You can use the adapter by\nwrapping the Flask app,\n\n.. code-block:: python\n\n    from asgiref.wsgi import WsgiToAsgi\n    from flask import Flask\n\n    app = Flask(__name__)\n\n    ...\n\n    asgi_app = WsgiToAsgi(app)\n\nan"
      },
      {
        "file_path": "tests\\test_apps\\helloworld\\wsgi.py",
        "avg_score": 0.0,
        "queries": [
          "mSQL v2.0.1 and below allows remote execution through a buffer overflow."
        ],
        "content_snippet": "from hello import app  # noqa: F401\n"
      },
      {
        "file_path": "examples\\tutorial\\flaskr\\db.py",
        "avg_score": 0.0,
        "queries": [
          "mSQL v2.0.1 and below allows remote execution through a buffer overrun."
        ],
        "content_snippet": "import sqlite3\nfrom datetime import datetime\n\nimport click\nfrom flask import current_app\nfrom flask import g\n\n\ndef get_db():\n    \"\"\"Connect to the application's configured database. The connection\n    is unique for each request and will be reused if this is called\n    again.\n    \"\"\"\n    if \"db\" not in g:\n        g.db = sqlite3.connect(\n            current_app.config[\"DATABASE\"], detect_types=sqlite3.PARSE_DECLTYPES\n        )\n        g.db.row_factory = sqlite3.Row\n\n    return g.db\n\n\ndef close_db("
      },
      {
        "file_path": "tests\\static\\index.html",
        "avg_score": 0.0,
        "queries": [
          "mSQL v2.0.1 and below allows remote execution through a stack overflow."
        ],
        "content_snippet": "<h1>Hello World!</h1>\n"
      },
      {
        "file_path": "tests\\test_apps\\cliapp\\multiapp.py",
        "avg_score": 0.0,
        "queries": [
          "mSQL v2.0.1 and below allows remote execution through a stack overflow."
        ],
        "content_snippet": "from flask import Flask\n\napp1 = Flask(\"app1\")\napp2 = Flask(\"app2\")\n"
      }
    ]
  },
  "detailed_matches": [
    {
      "file_path": "examples\\tutorial\\tests\\data.sql",
      "actual_path": "F:\\Programs\\Vuln_detection\\app\\retrieval\\codebase_indexing\\flask\\examples\\tutorial\\tests\\data.sql",
      "score": 0.0,
      "query": "mSQL v2.0.1 and below allows remote execution through a buffer overflow.",
      "content": "INSERT INTO user (username, password)\nVALUES\n  ('test', 'pbkdf2:sha256:50000$TCI4GzcX$0de171a4f4dac32e3364c7ddc7c14f3e2fa61f2d17574483f7ffbb431b4acb2f'),\n  ('other', 'pbkdf2:sha256:50000$kJPKsz6N$d2d4784f1b030a9761f5ccaeeaca413f27f2ecb76d6168407af962ddce849f79');\n\nINSERT INTO post (title, body, author_id, created)\nVALUES\n  ('test title', 'test' || x'0a' || 'body', 1, '2018-01-01 00:00:00');\n",
      "content_preview": "INSERT INTO user (username, password)\nVALUES\n  ('test', 'pbkdf2:sha256:50000$TCI4GzcX$0de171a4f4dac32e3364c7ddc7c14f3e2fa61f2d17574483f7ffbb431b4acb2f'),\n  ('other', 'pbkdf2:sha256:50000$kJPKsz6N$d2d4784f1b030a9761f5ccaeeaca413f27f2ecb76d6168407af962ddce849f79');\n\nINSERT INTO post (title, body, author_id, created)\nVALUES\n  ('test title', 'test' || x'0a' || 'body', 1, '2018-01-01 00:00:00');\n",
      "content_length": 394
    },
    {
      "file_path": "examples\\tutorial\\flaskr\\schema.sql",
      "actual_path": "F:\\Programs\\Vuln_detection\\app\\retrieval\\codebase_indexing\\flask\\examples\\tutorial\\flaskr\\schema.sql",
      "score": 0.0,
      "query": "mSQL v2.0.1 and below allows remote execution through a buffer overflow.",
      "content": "-- Initialize the database.\n-- Drop any existing data and create empty tables.\n\nDROP TABLE IF EXISTS user;\nDROP TABLE IF EXISTS post;\n\nCREATE TABLE user (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  username TEXT UNIQUE NOT NULL,\n  password TEXT NOT NULL\n);\n\nCREATE TABLE post (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  author_id INTEGER NOT NULL,\n  created TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  title TEXT NOT NULL,\n  body TEXT NOT NULL,\n  FOREIGN KEY (author_id) REFERENCES user (id)\n);\n",
      "content_preview": "-- Initialize the database.\n-- Drop any existing data and create empty tables.\n\nDROP TABLE IF EXISTS user;\nDROP TABLE IF EXISTS post;\n\nCREATE TABLE user (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  username TEXT UNIQUE NOT NULL,\n  password TEXT NOT NULL\n);\n\nCREATE TABLE post (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  author_id INTEGER NOT NULL,\n  created TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  title TEXT NOT NULL,\n  body TEXT NOT NULL,\n  FOREIGN KEY (author_id) REFERENCES user (id)\n);\n",
      "content_length": 498
    },
    {
      "file_path": "src\\flask\\__main__.py",
      "actual_path": "F:\\Programs\\Vuln_detection\\app\\retrieval\\codebase_indexing\\flask\\src\\flask\\__main__.py",
      "score": 0.0,
      "query": "mSQL v2.0.1 and below allows remote execution through a buffer overflow.",
      "content": "from .cli import main\n\nmain()\n",
      "content_preview": "from .cli import main\n\nmain()\n",
      "content_length": 30
    },
    {
      "file_path": "docs\\deploying\\asgi.rst",
      "actual_path": "F:\\Programs\\Vuln_detection\\app\\retrieval\\codebase_indexing\\flask\\docs\\deploying\\asgi.rst",
      "score": 0.0,
      "query": "mSQL v2.0.1 and below allows remote execution through a buffer overflow.",
      "content": "ASGI\n====\n\nIf you'd like to use an ASGI server you will need to utilise WSGI to\nASGI middleware. The asgiref\n`WsgiToAsgi <https://github.com/django/asgiref#wsgi-to-asgi-adapter>`_\nadapter is recommended as it integrates with the event loop used for\nFlask's :ref:`async_await` support. You can use the adapter by\nwrapping the Flask app,\n\n.. code-block:: python\n\n    from asgiref.wsgi import WsgiToAsgi\n    from flask import Flask\n\n    app = Flask(__name__)\n\n    ...\n\n    asgi_app = WsgiToAsgi(app)\n\nand then serving the ``asgi_app`` with the ASGI server, e.g. using\n`Hypercorn <https://github.com/pgjones/hypercorn>`_,\n\n.. sourcecode:: text\n\n    $ hypercorn module:asgi_app\n",
      "content_preview": "ASGI\n====\n\nIf you'd like to use an ASGI server you will need to utilise WSGI to\nASGI middleware. The asgiref\n`WsgiToAsgi <https://github.com/django/asgiref#wsgi-to-asgi-adapter>`_\nadapter is recommended as it integrates with the event loop used for\nFlask's :ref:`async_await` support. You can use the adapter by\nwrapping the Flask app,\n\n.. code-block:: python\n\n    from asgiref.wsgi import WsgiToAsgi\n    from flask import Flask\n\n    app = Flask(__name__)\n\n    ...\n\n    asgi_app = WsgiToAsgi(app)\n\nan...",
      "content_length": 673
    },
    {
      "file_path": "tests\\test_apps\\helloworld\\wsgi.py",
      "actual_path": "F:\\Programs\\Vuln_detection\\app\\retrieval\\codebase_indexing\\flask\\tests\\test_apps\\helloworld\\wsgi.py",
      "score": 0.0,
      "query": "mSQL v2.0.1 and below allows remote execution through a buffer overflow.",
      "content": "from hello import app  # noqa: F401\n",
      "content_preview": "from hello import app  # noqa: F401\n",
      "content_length": 36
    },
    {
      "file_path": "examples\\tutorial\\flaskr\\db.py",
      "actual_path": "F:\\Programs\\Vuln_detection\\app\\retrieval\\codebase_indexing\\flask\\examples\\tutorial\\flaskr\\db.py",
      "score": 0.0,
      "query": "mSQL v2.0.1 and below allows remote execution through a buffer overrun.",
      "content": "import sqlite3\nfrom datetime import datetime\n\nimport click\nfrom flask import current_app\nfrom flask import g\n\n\ndef get_db():\n    \"\"\"Connect to the application's configured database. The connection\n    is unique for each request and will be reused if this is called\n    again.\n    \"\"\"\n    if \"db\" not in g:\n        g.db = sqlite3.connect(\n            current_app.config[\"DATABASE\"], detect_types=sqlite3.PARSE_DECLTYPES\n        )\n        g.db.row_factory = sqlite3.Row\n\n    return g.db\n\n\ndef close_db(e=None):\n    \"\"\"If this request connected to the database, close the\n    connection.\n    \"\"\"\n    db = g.pop(\"db\", None)\n\n    if db is not None:\n        db.close()\n\n\ndef init_db():\n    \"\"\"Clear existing data and create new tables.\"\"\"\n    db = get_db()\n\n    with current_app.open_resource(\"schema.sql\") as f:\n        db.executescript(f.read().decode(\"utf8\"))\n\n\n@click.command(\"init-db\")\ndef init_db_command():\n    \"\"\"Clear existing data and create new tables.\"\"\"\n    init_db()\n    click.echo(\"Initialized the database.\")\n\n\nsqlite3.register_converter(\"timestamp\", lambda v: datetime.fromisoformat(v.decode()))\n\n\ndef init_app(app):\n    \"\"\"Register database functions with the Flask app. This is called by\n    the application factory.\n    \"\"\"\n    app.teardown_appcontext(close_db)\n    app.cli.add_command(init_db_command)\n",
      "content_preview": "import sqlite3\nfrom datetime import datetime\n\nimport click\nfrom flask import current_app\nfrom flask import g\n\n\ndef get_db():\n    \"\"\"Connect to the application's configured database. The connection\n    is unique for each request and will be reused if this is called\n    again.\n    \"\"\"\n    if \"db\" not in g:\n        g.db = sqlite3.connect(\n            current_app.config[\"DATABASE\"], detect_types=sqlite3.PARSE_DECLTYPES\n        )\n        g.db.row_factory = sqlite3.Row\n\n    return g.db\n\n\ndef close_db(...",
      "content_length": 1317
    },
    {
      "file_path": "tests\\static\\index.html",
      "actual_path": "F:\\Programs\\Vuln_detection\\app\\retrieval\\codebase_indexing\\flask\\tests\\static\\index.html",
      "score": 0.0,
      "query": "mSQL v2.0.1 and below allows remote execution through a stack overflow.",
      "content": "<h1>Hello World!</h1>\n",
      "content_preview": "<h1>Hello World!</h1>\n",
      "content_length": 22
    },
    {
      "file_path": "tests\\test_apps\\cliapp\\multiapp.py",
      "actual_path": "F:\\Programs\\Vuln_detection\\app\\retrieval\\codebase_indexing\\flask\\tests\\test_apps\\cliapp\\multiapp.py",
      "score": 0.0,
      "query": "mSQL v2.0.1 and below allows remote execution through a stack overflow.",
      "content": "from flask import Flask\n\napp1 = Flask(\"app1\")\napp2 = Flask(\"app2\")\n",
      "content_preview": "from flask import Flask\n\napp1 = Flask(\"app1\")\napp2 = Flask(\"app2\")\n",
      "content_length": 67
    }
  ]
}