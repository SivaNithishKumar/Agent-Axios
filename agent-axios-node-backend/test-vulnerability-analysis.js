/**
 * Test autonomous vulnerability analysis on a Flask repository
 */

const axios = require('axios');

const API_BASE = 'http://localhost:3000/api';

async function testVulnerabilityAnalysis() {
  console.log('\nğŸ§ª Testing Autonomous Vulnerability Analysis');
  console.log('â•'.repeat(70));

  try {
    // Start conversation
    console.log('\n1ï¸âƒ£ Starting conversation...');
    const startRes = await axios.post(`${API_BASE}/conversation/start`, {
      userId: 'vuln-test-user',
      agentType: 'langgraph',
    });

    const conversationId = startRes.data.conversationId;
    console.log('âœ… Conversation ID:', conversationId);

    // Send vulnerability analysis request with GitHub repo
    console.log('\n2ï¸âƒ£ Requesting vulnerability analysis...');
    console.log('ğŸ“¦ Repository: https://github.com/pallets/flask');
    console.log('ğŸ¯ Task: Find security vulnerabilities\n');

    const message = `Analyze this Flask repository for security vulnerabilities: https://github.com/pallets/flask

Please:
1. Clone the repository
2. Analyze the code structure
3. Search for common vulnerabilities (SQL injection, XSS, path traversal, etc.)
4. Use the CVE database to find relevant vulnerabilities
5. Validate any potential matches
6. Record confirmed findings
7. Generate a vulnerability report

This is a complete security audit - perform all steps automatically.`;

    let toolsUsed = [];
    let currentStep = '';
    let vulnerabilitiesFound = 0;
    let reportGenerated = false;

    console.log('ğŸ”„ Streaming analysis (this may take a few minutes)...\n');

    const response = await axios.post(
      `${API_BASE}/conversation/message-stream`,
      { conversationId, message },
      { responseType: 'stream', timeout: 600000 } // 10 min timeout
    );

    let responseText = '';

    response.data.on('data', (chunk) => {
      const lines = chunk.toString().split('\n');
      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = line.slice(6);
          if (data === '[DONE]') {
            console.log('\nâœ… Analysis stream completed\n');
            return;
          }

          try {
            const event = JSON.parse(data);
            
            if (event.type === 'tool_start') {
              currentStep = event.toolName;
              toolsUsed.push(event.toolName);
              
              const stepEmoji = {
                'clone_repository': 'ğŸ“¥',
                'analyze_repository_structure': 'ğŸ”',
                'build_codebase_index': 'ğŸ“š',
                'search_codebase_semantically': 'ğŸ”',
                'search_cve_database': 'ğŸ”’',
                'validate_vulnerability_match': 'âœ”ï¸',
                'record_finding': 'ğŸ’¾',
                'generate_vulnerability_report': 'ğŸ“„'
              }[event.toolName] || 'ğŸ”§';

              console.log(`${stepEmoji} Starting: ${event.toolName}`);
              
              if (event.toolInput) {
                const input = JSON.stringify(event.toolInput);
                if (input.length < 100) {
                  console.log(`   Input: ${input}`);
                }
              }
            } 
            else if (event.type === 'tool_end') {
              console.log(`   âœ“ Completed: ${event.toolName}`);
              
              if (event.toolName === 'record_finding') {
                vulnerabilitiesFound++;
              }
              if (event.toolName === 'generate_vulnerability_report') {
                reportGenerated = true;
              }
            } 
            else if (event.type === 'custom') {
              console.log(`   ${event.content}`);
            }
            else if (event.type === 'token') {
              responseText += event.content;
            }
            else if (event.type === 'error') {
              console.error(`   âŒ Error: ${event.error}`);
            }
          } catch (e) {
            // Ignore parse errors
          }
        }
      }
    });

    await new Promise((resolve, reject) => {
      response.data.on('end', resolve);
      response.data.on('error', reject);
    });

    // Results summary
    console.log('â•'.repeat(70));
    console.log('\nğŸ“Š ANALYSIS RESULTS\n');
    console.log(`âœ… Tools Used: ${toolsUsed.length}`);
    console.log(`   ${toolsUsed.join(', ')}\n`);
    
    console.log(`ğŸ”’ Vulnerabilities Found: ${vulnerabilitiesFound}`);
    console.log(`ğŸ“„ Report Generated: ${reportGenerated ? 'Yes' : 'No'}\n`);

    if (responseText.length > 0) {
      console.log('ğŸ¤– Agent Response:');
      console.log('â”€'.repeat(70));
      console.log(responseText.substring(0, 500) + (responseText.length > 500 ? '...' : ''));
      console.log('â”€'.repeat(70) + '\n');
    }

    // Tool usage verification
    const requiredTools = [
      'clone_repository',
      'analyze_repository_structure',
      'search_cve_database'
    ];

    const missingTools = requiredTools.filter(tool => !toolsUsed.includes(tool));
    
    if (missingTools.length > 0) {
      console.log(`âš ï¸  Missing expected tools: ${missingTools.join(', ')}`);
    } else {
      console.log('âœ… All required tools were used!');
    }

    // Clean up
    console.log('\n3ï¸âƒ£ Cleaning up...');
    await axios.delete(`${API_BASE}/conversation/${conversationId}`);
    console.log('âœ… Conversation ended\n');

    // Final verdict
    console.log('â•'.repeat(70));
    if (toolsUsed.includes('clone_repository') && 
        toolsUsed.includes('search_cve_database') &&
        vulnerabilitiesFound >= 0) {
      console.log('âœ… AUTONOMOUS VULNERABILITY ANALYSIS: SUCCESS!');
    } else {
      console.log('âš ï¸  AUTONOMOUS VULNERABILITY ANALYSIS: PARTIAL SUCCESS');
      console.log('   The agent executed but may not have completed all steps.');
    }
    console.log('â•'.repeat(70) + '\n');

  } catch (error) {
    console.error('\nâŒ Test failed:', error.response?.data || error.message);
    if (error.code === 'ECONNABORTED') {
      console.error('   Analysis timed out - this is normal for large repos');
    }
    throw error;
  }
}

// Run the test
console.log('\nğŸš€ Starting Flask Repository Vulnerability Analysis Test');
console.log('â±ï¸  Note: This test may take 5-10 minutes for a full analysis\n');

testVulnerabilityAnalysis().catch(err => {
  console.error('Test execution failed');
  process.exit(1);
});
